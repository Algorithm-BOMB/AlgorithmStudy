# 시간복잡도 & Big-O 표기법

## 시간복잡도

- 특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간
- 알고리즘을 구성하는 명령어들이 몇 번이나 실행이 되는지를 센 결과에 각 명령어의 실행시간을 곱한 합계를 의미

## Big-O(빅 오) 표기법

- O(n)으로 표기한다.
- O(n)은 입력되는 n에 따라 결정되는 시간 복잡도 함수이다.
- O(1), O(logn), O(n), O(nlogn), O(n<sup>2</sup>), O(2<sup>n</sup>), O(n!) 등으로 표기한다.
- 입력되는 n의 크기에 따라 시간 복잡도가 기하급수적으로 늘어날 수 있다.

### 시간 복잡도 크기 순서

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(2<sup>n</sup>) < O(n!)
```

### 1. 상수시간 O(1)

입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘. <br>
데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다. <br>

- 배열의 n번째 원소에 접근
- 스택에 push / pop
- 큐에 삽입 / 삭제
- 해시 테이블의 원소에 접근

### 2. 로그시간 O(logn)

입력 데이터의 크기가 커질수록 처리시간이 로그만큼 짧아지는 알고리즘.<br>
데이터가 10배가 되면, 처리시간은 2배가 된다.

- 이진탐색(binary search) 알고리즘

### 3. 선형시간 O(n)

입력 데이터의 크기에 비례해 처리시간이 증가하는 알고리즘.<br>
데이터가 10배가 되면, 처리시간도 10배가 된다. <br>

- 선형탐색(linear search) 알고리즘
- 배열에서 검색, 최솟/최댓값 찾기 등 연산
- 연결리스트에서 순회, 최솟/최댓값 찾기 등 연산

### 4. N 로그 N 시간 O(nlogn)

데이터가 많아질수록 처리시간이 로그 배 만큼 더 늘어나는 알고리즘.<br>
데이터가 10배가 되면, 처리시간은 약 20배가 된다. <br>
알고리즘의 실행시간이 입력크기와 입력크기의 로그 곱에 비례. <br>
이런 알고리즘은 입력의 절반(또는 일부)으로 나눌 때마다 각 부분을 독립적으로 처리. <br>

- 병합 정렬(merge sort)
- 퀵 정렬(quick sort) -> 평균적인 성능, 최악의 시간 복잡도는 O(n<sup>2</sup>)
- 힙 정렬(heap sort)

### 5. 이차시간 O(n<sup>2</sup>)

데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘. <br>
데이터가 10배가 되면, 처리시간은 최대 100배가 된다. <br>
알고리즘의 실행시간이 입력크기의 제곱에 비례. <br>
이런 알고리즘은 각 원소를 다른 모든 원소와 비교. <br>

- 버블 정렬(bubble sort)
- 선택 정렬 (selectrion sort)
- 삽입 정렬(insertion sort)

### 6. 지수시간 O(2<sup>n</sup>)

데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘. <br>
입력 데이터들의 원소들로 만들 수 있는 모든 부분 집합을 생성. <br>

- 피보나치 수열
- 재귀가 역기능 할 경우

### 7. 계승시간 O(n!)

입력 데이터의 원소들로 만들 수 있는 모든 순열을 생성

## 시간복잡도를 구하는 요령

- 하나의 루프를 사용하여 단일 요소 집합을 반복하는 경우 : O(n)
- 컬렉션의 절반 이상을 반복히는 경우 : O(n/2) -> O(n)
- 두 개의 다른 루프를 사용하여 두 개의 개별 컬렉션을 반복할 경우 : O(n+m) -> O(n)
- 두 개의 중첩루프를 사용하여 단일 컬렉션을 반복하는 경우 : O(n<sup>2</sup>)
- 두 개의 중첩루프를 사용하여 두 개의 다른 컬렉션을 반복할 경우 : O(n\*m) -> O(n<sup>2</sup>)

## 어느 알고리즘의 성능이 좋은가

`1부터 n까지의 모든 수의 합` 을 구하는 알고리즘을 구현해보자! <br>

- 첫번째 알고리즘 \_ O(n)

```
function sum(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i;
    }
    return total;
}
```

- 두번째 알고리즘 \_ O(n)

```
function sum(n) {
    const total = n * (n + 1) / 2;
    return total;
}
```

## 자료 출처

- https://velog.io/@keemtj/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84
- https://velog.io/@raram2/big-o-notation-and-time-complexity
- https://coding-factory.tistory.com/608
