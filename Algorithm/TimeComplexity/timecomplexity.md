# 시간복잡도 & Big-O 표기법

## 시간복잡도

- 특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간
- 알고리즘을 구성하는 명령어들이 몇 번이나 실행이 되는지를 센 결과에 각 명령어의 실행시간을 곱한 합계를 의미

## Big-O(빅 오) 표기법

- O(n)으로 표기한다.
- O(n)은 입력되는 n에 따라 결정되는 시간 복잡도 함수이다.
- O(1), O(logn), O(n), O(nlogn), O(n<sup>2</sup>), O(2<sup>n</sup>), O(n!) 등으로 표기한다.
- 입력되는 n의 크기에 따라 시간 복잡도가 기하급수적으로 늘어날 수 있다.

### 시간 복잡도 크기 순서

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(2<sup>n</sup>) < O(n!)
```

1. 상수시간 O(1)
   입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘. <br>
   데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다. <br>

   - 배열의 n번째 원소에 접근
   - 스택에 push / pop
   - 큐에 삽입 / 삭제
   - 해시 테이블의 원소에 접근

2. 선형시간 O(n)
   알고리즘의 실행시간이 입력 크기의 로그에 비례. <br>

   - 배열에서 검색, 최솟/최댓값 찾기 등 연산
   - 연결리스트에서 순회, 최솟/최댓값 찾기 등 연산

3. 로그시간 O(logn)
   알고리즘의 실행시간이 입력 크기의 로그에 비례. <br>
   알고리즘의 각 단계에서 입력의 상당부분(절반)을 방문하지 않고 지나간다.

   - 이진탐색(binary search) 알고리즘

4. N 로그 N 시간 O(nlogn)
   알고리즘의 실행 시간이 입력크기와 입력크기의 로그 곱에 비례.
   이런 알고리즘은 입력의 절반(또는 일부)으로 나눌 때마다 각 부분을 독립적으로 처리

   - 병합 정렬(merge sort)
   - 퀵 정렬(quick sort) -> 평균적인 성능, 최악의 시간 복잡도는 O(n<sup>2</sup>)
   - 힙 정렬(heap sort)

5. 이차시간 O(n<sup>2</sup>)
   알고리즘의 실행시간이 입력크기의 제곱에 비례
   이런 알고리즘은 각 원소를 다른 모든 원소와 비교

   - 버블 정렬(bubble sort)
   - 선택 정렬 (selectrion sort)
   - 삽입 정렬(insertion sort)

6. 지수시간 O(2<sup>n</sup>)
   입력 데이터들의 원소들로 만들 수 있는 모든 부분 집합을 생성

7. 계승시간 O(n!)
   입력 데이터의 원소들로 만들 수 있는 모든 순열을 생성
